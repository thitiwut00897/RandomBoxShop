{"ast":null,"code":"var _LineNotificationService;\nclass LineNotificationService {\n  constructor() {\n    this.notifications = [];\n  }\n  static getInstance() {\n    if (!LineNotificationService.instance) {\n      LineNotificationService.instance = new LineNotificationService();\n    }\n    return LineNotificationService.instance;\n  }\n  async sendNotification(message, type = 'info') {\n    const notification = {\n      message,\n      timestamp: new Date(),\n      type\n    };\n    this.notifications.push(notification);\n\n    // In a real application, you would integrate with Line Notify API\n    // For now, we'll simulate the API call\n    console.log(`[LINE NOTIFICATION] ${type.toUpperCase()}: ${message}`);\n\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // You would typically make an HTTP request to Line Notify API like this:\n    /*\n    const response = await fetch('https://notify-api.line.me/api/notify', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${process.env.REACT_APP_LINE_NOTIFY_TOKEN}`,\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: `message=${encodeURIComponent(message)}`,\n    });\n    \n    if (!response.ok) {\n      throw new Error('Failed to send Line notification');\n    }\n    */\n  }\n  async sendPurchaseSuccessNotification(userName, orderTotal, items) {\n    const message = `ðŸŽ‰ Purchase Successful!\\n\\nUser: ${userName}\\nTotal: $${orderTotal.toFixed(2)}\\nItems: ${items.join(', ')}\\n\\nThank you for your purchase!`;\n    await this.sendNotification(message, 'success');\n  }\n  async sendSpinnerWinNotification(userName, itemName, rarity) {\n    const message = `ðŸŽ° Lucky Spin!\\n\\nUser: ${userName}\\nWon: ${itemName}\\nRarity: ${rarity.toUpperCase()}\\n\\nCongratulations!`;\n    await this.sendNotification(message, 'success');\n  }\n  async sendPetBoxPurchaseNotification(userName, pets) {\n    const rarityCounts = pets.reduce((acc, pet) => {\n      acc[pet.rarity] = (acc[pet.rarity] || 0) + 1;\n      return acc;\n    }, {});\n    const raritySummary = Object.entries(rarityCounts).map(([rarity, count]) => `${rarity}: ${count}`).join(', ');\n    const topRarity = pets.reduce((highest, pet) => {\n      const rarityOrder = ['Common', 'Uncommon', 'Rare', 'Legendary', 'Mythical', 'Divine', 'Prismatic'];\n      const currentIndex = rarityOrder.indexOf(pet.rarity);\n      const highestIndex = rarityOrder.indexOf(highest.rarity);\n      return currentIndex > highestIndex ? pet : highest;\n    });\n    const message = `ðŸ¾ Pet Box Opened!\\n\\nUser: ${userName}\\nBox Contents: ${raritySummary}\\n\\nBest Pet: ${topRarity.name} (${topRarity.rarity})\\n\\n${pets.map(pet => `${pet.image} ${pet.name}`).join('\\n')}\\n\\nEnjoy your new pets!`;\n    await this.sendNotification(message, 'success');\n  }\n  getNotifications() {\n    return [...this.notifications];\n  }\n  clearNotifications() {\n    this.notifications = [];\n  }\n}\n_LineNotificationService = LineNotificationService;\nLineNotificationService.instance = void 0;\nexport const lineNotificationService = LineNotificationService.getInstance();","map":{"version":3,"names":["LineNotificationService","constructor","notifications","getInstance","instance","sendNotification","message","type","notification","timestamp","Date","push","console","log","toUpperCase","Promise","resolve","setTimeout","sendPurchaseSuccessNotification","userName","orderTotal","items","toFixed","join","sendSpinnerWinNotification","itemName","rarity","sendPetBoxPurchaseNotification","pets","rarityCounts","reduce","acc","pet","raritySummary","Object","entries","map","count","topRarity","highest","rarityOrder","currentIndex","indexOf","highestIndex","name","image","getNotifications","clearNotifications","_LineNotificationService","lineNotificationService"],"sources":["/Users/thitiwutphophan/shop/src/services/lineNotification.ts"],"sourcesContent":["import { LineNotification, Pet } from '../types';\n\nclass LineNotificationService {\n  private static instance: LineNotificationService;\n  private notifications: LineNotification[] = [];\n\n  private constructor() {}\n\n  static getInstance(): LineNotificationService {\n    if (!LineNotificationService.instance) {\n      LineNotificationService.instance = new LineNotificationService();\n    }\n    return LineNotificationService.instance;\n  }\n\n  async sendNotification(message: string, type: 'success' | 'error' | 'info' = 'info'): Promise<void> {\n    const notification: LineNotification = {\n      message,\n      timestamp: new Date(),\n      type,\n    };\n\n    this.notifications.push(notification);\n\n    // In a real application, you would integrate with Line Notify API\n    // For now, we'll simulate the API call\n    console.log(`[LINE NOTIFICATION] ${type.toUpperCase()}: ${message}`);\n    \n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // You would typically make an HTTP request to Line Notify API like this:\n    /*\n    const response = await fetch('https://notify-api.line.me/api/notify', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${process.env.REACT_APP_LINE_NOTIFY_TOKEN}`,\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: `message=${encodeURIComponent(message)}`,\n    });\n    \n    if (!response.ok) {\n      throw new Error('Failed to send Line notification');\n    }\n    */\n  }\n\n  async sendPurchaseSuccessNotification(userName: string, orderTotal: number, items: string[]): Promise<void> {\n    const message = `ðŸŽ‰ Purchase Successful!\\n\\nUser: ${userName}\\nTotal: $${orderTotal.toFixed(2)}\\nItems: ${items.join(', ')}\\n\\nThank you for your purchase!`;\n    \n    await this.sendNotification(message, 'success');\n  }\n\n  async sendSpinnerWinNotification(userName: string, itemName: string, rarity: string): Promise<void> {\n    const message = `ðŸŽ° Lucky Spin!\\n\\nUser: ${userName}\\nWon: ${itemName}\\nRarity: ${rarity.toUpperCase()}\\n\\nCongratulations!`;\n    \n    await this.sendNotification(message, 'success');\n  }\n\n  async sendPetBoxPurchaseNotification(userName: string, pets: Pet[]): Promise<void> {\n    const rarityCounts = pets.reduce((acc, pet) => {\n      acc[pet.rarity] = (acc[pet.rarity] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const raritySummary = Object.entries(rarityCounts)\n      .map(([rarity, count]) => `${rarity}: ${count}`)\n      .join(', ');\n\n    const topRarity = pets.reduce((highest, pet) => {\n      const rarityOrder = ['Common', 'Uncommon', 'Rare', 'Legendary', 'Mythical', 'Divine', 'Prismatic'];\n      const currentIndex = rarityOrder.indexOf(pet.rarity);\n      const highestIndex = rarityOrder.indexOf(highest.rarity);\n      return currentIndex > highestIndex ? pet : highest;\n    });\n\n    const message = `ðŸ¾ Pet Box Opened!\\n\\nUser: ${userName}\\nBox Contents: ${raritySummary}\\n\\nBest Pet: ${topRarity.name} (${topRarity.rarity})\\n\\n${pets.map(pet => `${pet.image} ${pet.name}`).join('\\n')}\\n\\nEnjoy your new pets!`;\n    \n    await this.sendNotification(message, 'success');\n  }\n\n  getNotifications(): LineNotification[] {\n    return [...this.notifications];\n  }\n\n  clearNotifications(): void {\n    this.notifications = [];\n  }\n}\n\nexport const lineNotificationService = LineNotificationService.getInstance(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}